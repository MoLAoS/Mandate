<!--
     This file is a part of The Glest Advanced Engine.
     Copyright (C) 2010-2011 Nathan Turner & James McCulloch
     GPL V2, see source/licence.txt
-->

<unit-shader-set name="basic">

	<description>
		<![CDATA[
			A basic shader set using per-vertex lighting and diffuse texture only.
		]]>
	</description>
	
	<glsl-version value="110" />
	
	<!-- varying and uniform vars -->
	<variables>
		<![CDATA[
			varying float diffuseIntensity, fogFactor, meshAlpha;
			uniform int isUsingFog;
			uniform vec3 teamColour;
			uniform sampler2D baseTexture;
		]]>
	</variables>

	<vertex-shader>
		<![CDATA[
			void main() {
				// pass-on tex-coord & mesh colour
				gl_TexCoord[0] = gl_MultiTexCoord0;
				gl_FrontColor = gl_Color;
				meshAlpha = gl_Color.a;

				// Lighting (diffuse only, everything currently has Material.specular set to (0, 0, 0, 1))
				vec3 normal = normalize(gl_NormalMatrix * gl_Normal);       // convert normal to eye space
				vec3 lightDir = normalize(gl_LightSource[0].position.xyz);  // direction of main light source
				diffuseIntensity =	max(dot(lightDir, normal), 0.0);        // calculate diffuse term
				
				// fog
				if (isUsingFog == 1) {
					float dist = length(vec3(gl_ModelViewMatrix * gl_Vertex)); // distance from camera
					const float log_2 = 1.442695;
					fogFactor = exp2(-gl_Fog.density * gl_Fog.density * dist * dist * log_2);
					fogFactor = clamp(fogFactor, 0.0, 1.0);	
				} else {
					fogFactor = 1.f;
				}
				
				// Transform vertex
				gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
			}
		]]>
	</vertex-shader>	
	
	<base-vertex-shader>
		<![CDATA[
			void main() {
				// pass-on tex-coord & mesh alpha
				gl_TexCoord[0] = gl_MultiTexCoord0;
				meshAlpha = gl_Color.a;

				// direction of main light source
				vec3 lightDir = normalize(vec3(gl_LightSource[0].position));
				vec3 normal = normalize(gl_NormalMatrix * gl_Normal);
				
				// diffuse shading
				diffuseIntensity = max(dot(lightDir, normal), 0.0);
				
				// fog
				float dist = length(vec3(gl_ModelViewMatrix * gl_Vertex)); // distance from camera
				const float log_2 = 1.442695;
				fogFactor = exp2(-gl_Fog.density * gl_Fog.density * dist * dist * log_2);
				fogFactor = clamp(fogFactor, 0.0, 1.0);	
				
				// determine pixel position
				gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
			}
		]]>
	</base-vertex-shader>

	<lerp-vertex-shader>
		<![CDATA[
			attribute vec3 nextVertex;
			attribute vec3 nextNormal;
			uniform float t;
			
			void main() {
				// pass-on tex-coord & mesh alpha
				gl_TexCoord[0] = gl_MultiTexCoord0;
				meshAlpha = gl_Color.a;
				
				// direction of main light source
				vec3 lightDir = normalize(vec3(gl_LightSource[0].position));
				
				vec3 normal = mix(gl_Normal, nextNormal, t);
				normal = normalize(gl_NormalMatrix * gl_Normal);
				
				// diffuse shading
				diffuseIntensity = max(dot(lightDir, normal), 0.0);
				
				// fog
				float dist = length(vec3(gl_ModelViewMatrix * gl_Vertex)); // distance from camera
				const float log_2 = 1.442695;
				fogFactor = exp2(-gl_Fog.density * gl_Fog.density * dist * dist * log_2);
				fogFactor = clamp(fogFactor, 0.0, 1.0);	
				
				// determine pixel position
				vec3 pos = mix(gl_Vertex, nextVertex, t);
				gl_Position = gl_ModelViewProjectionMatrix * pos;
			}
		]]>
	</lerp-vertex-shader>

	<team-fragment-shader>
		<![CDATA[
			void main() {
				// sample texture
				vec4 texDiffuseBase = texture2D(baseTexture, vec2(gl_TexCoord[0].st));
				
				// interpolate the base and team colour according to the base alpha
				vec3 baseColour = mix(teamColour, texDiffuseBase.rgb, texDiffuseBase.a);

				// light components
				vec3 diffuse = gl_FrontLightProduct[0].diffuse.rgb * diffuseIntensity;
				vec3 ambient = gl_FrontLightProduct[0].ambient.rgb + gl_FrontLightModelProduct.sceneColor.rgb;

				// final colour
				vec4 finalColour = vec4((ambient + diffuse) * baseColour, meshAlpha);
				gl_FragColor = mix(gl_Fog.color, finalColour, fogFactor);
			}
		]]>
	</team-fragment-shader>

	<rgba-fragment-shader>
		<![CDATA[
			void main() {
				// sample texture
				vec4 baseColour = texture2D(baseTexture, vec2(gl_TexCoord[0].st));

				// light components
				vec3 diffuse = gl_FrontLightProduct[0].diffuse.rgb * diffuseIntensity;
				vec3 ambient = gl_FrontLightProduct[0].ambient.rgb + gl_FrontLightModelProduct.sceneColor.rgb;
				vec3 lightColour = ambient + diffuse;

				// final colour
				vec4 finalColour = vec4(lightColour * baseColour.rgb, meshAlpha * baseColour.a);
				gl_FragColor = mix(gl_Fog.color, finalColour, fogFactor);
			}
		]]>
	</rgba-fragment-shader>

</unit-shader-set>
