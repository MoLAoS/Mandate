<!--
     This file is a part of The Glest Advanced Engine.
     Copyright (C) 2010-2011 Nathan Turner & James McCulloch
     GPL V2, see source/licence.txt
-->

<unit-shader-set name="bump">

	<description>
		<![CDATA[
			A bump-mapping shader set, using per-pixel lighting & a normal map (where present).
		]]>
	</description>
	
	<glsl-version value="110" />
	
	<variables>
		<![CDATA[
			varying vec3     normal,      // normal vector in eye space
			                 esLightDir,  // light direction vector in eye space
							 tsLightDir;  // light direction vector in tangent space
							 
			varying vec3     meshColour;
							 //, eyeVec;

			varying float    fogFactor,
			                 meshAlpha;

			uniform float      gae_AlphaThreshold;
			uniform int        gae_IsUsingFog;
			uniform int        gae_HasNormalMap;
			uniform vec3       gae_TeamColour;
			uniform sampler2D  gae_DiffuseTex;
			uniform sampler2D  gae_NormalMap;
		]]>
	</variables>

	<vertex-shader>
		<![CDATA[
			attribute vec3 gae_Tangent;
			
			void main() {
				gl_TexCoord[0] = gl_MultiTexCoord0;
				meshColour = gl_Color.rgb;
				meshAlpha = gl_Color.a;
				
				normal = gl_NormalMatrix * gl_Normal; // pass normal to frag shader
				esLightDir = normalize(gl_LightSource[0].position.xyz); // light dir in eye space

				if (gae_HasNormalMap == 1) {
					// Build TBN vectors
					// for normal mapping : from http://www.ozone3d.net/tutorials/bump_mapping_p4.php
					vec3 n = normal;
					vec3 t = normalize(gl_NormalMatrix * gae_Tangent);
					vec3 b = cross(n, t);

					// Transform light dir to tangent space
					vec3 vertex = vec3(gl_ModelViewMatrix * gl_Vertex);
					vec3 tmpVec = normalize(gl_LightSource[0].position.xyz - vertex);
					tsLightDir = vec3(dot(tmpVec, t), dot(tmpVec, b), dot(tmpVec, n)); // light dir in tangent space
				}
				// Transform eye pos to tangent space (will need for spec mapping)
				//tmpVec = -vertex;
				//eyeVec.x = dot(tmpVec, t);
				//eyeVec.y = dot(tmpVec, b);
				//eyeVec.z = dot(tmpVec, n);

				// fog
				//if (gae_IsUsingFog == 1) {
					float dist = length(vec3(gl_ModelViewMatrix * gl_Vertex)); // distance from camera
					dist *= float(gae_IsUsingFog);
					const float log_2 = 1.442695;
					fogFactor = exp2(-gl_Fog.density * gl_Fog.density * dist * dist * log_2);
					fogFactor = clamp(fogFactor, 0.0, 1.0);	
				//} else {
				//	fogFactor = 1.f;
				//}
				
				// Transform vert
				gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
			}
		]]>
	</vertex-shader>

	<team-fragment-shader>
		<![CDATA[
			void main() {
				// sample diffuse texture
				vec4 texDiffuseBase = texture2D(gae_DiffuseTex, vec2(gl_TexCoord[0].st));
				
				// interpolate the base and team colour according to the base alpha
				vec3 baseColour = mix(gae_TeamColour, texDiffuseBase.rgb, texDiffuseBase.a);

				// diffuse shading
				vec3 normal = normalize(normal);
				float diffuseIntensity = max(dot(esLightDir, normal), 0.0);
				vec3 diffuse;
				if (gae_HasNormalMap == 1) {
					// calculate intensity from texture normal
					vec3 texNormalMap = texture2D(gae_NormalMap, vec2(gl_TexCoord[0].st)).xyz;
					vec3 n = normalize(texNormalMap * 2.0 - 1.0);
					float bump = max(dot(tsLightDir, n), 0.0);
					diffuse = gl_FrontLightProduct[0].diffuse.rgb * (bump * 0.8 + diffuseIntensity * 0.2)
							* meshColour;
				} else {
					diffuse = gl_FrontLightProduct[0].diffuse.rgb * diffuseIntensity * meshColour;
				}
				vec3 ambient = gl_FrontLightProduct[0].ambient.rgb + gl_FrontLightModelProduct.sceneColor.rgb;
				vec3 lightColour = clamp(ambient + diffuse, 0.0, 1.0);
				
				// final colour
				vec4 finalColour = vec4(lightColour * baseColour, meshAlpha);
				gl_FragColor = mix(gl_Fog.color, finalColour, fogFactor);
			}
		]]>
	</team-fragment-shader>

	<rgba-fragment-shader>
		<![CDATA[
			void main() {
				// sample diffuse texture
				vec4 texDiffuseBase = texture2D(gae_DiffuseTex, vec2(gl_TexCoord[0].st));
				
				// diffuse shading
				vec3 normal = normalize(normal);
				float diffuseIntensity = max(dot(esLightDir, normal), 0.0);
				vec3 diffuse;
				if (gae_HasNormalMap == 1) {
					// calculate intensity from texture normal
					vec3 texNormalMap = texture2D(gae_NormalMap, vec2(gl_TexCoord[0].st)).xyz;
					vec3 n = normalize(texNormalMap * 2.0 - 1.0);
					float bump = max(dot(tsLightDir, n), 0.0);
					diffuse = gl_FrontLightProduct[0].diffuse.rgb * (bump * 0.8 + diffuseIntensity * 0.2)
							* meshColour;
				} else {
					diffuse = gl_FrontLightProduct[0].diffuse.rgb * diffuseIntensity * meshColour;
				}
				vec3 ambient = gl_FrontLightProduct[0].ambient.rgb + gl_FrontLightModelProduct.sceneColor.rgb;
				vec3 lightColour = clamp(ambient + diffuse, 0.0, 1.0);
								
				// final colour
				vec4 finalColour = vec4(lightColour * texDiffuseBase.rgb, meshAlpha * texDiffuseBase.a);

				// below alpha threshold ?
				if (finalColour.a < gae_AlphaThreshold) {
					discard;
				}
				gl_FragColor = mix(gl_Fog.color, finalColour, fogFactor);
			}
		]]>
		</rgba-fragment-shader>
		
</unit-shader-set>
